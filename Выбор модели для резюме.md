# Resume Screener — Техническая спецификация для Claude Code

## Контекст проекта

Сервис проверки и переупаковки резюме. Пользователь загружает резюме (PDF/DOCX/текст), выбирает целевую роль, получает критику, скоринг, переупакованную версию и финальную оценку рекрутера.

**Стек:** FastAPI + anthropic SDK + Claude Haiku 4.5 + structured output + prompt caching
**Модель:** `claude-haiku-4-5-20251001`
**Формат ответов:** JSON Schema (structured output)

---

## Архитектура пайплайна

```
[Загрузка резюме] → [Парсинг] → [Шаг 0: Диагностика] ──┐
                                  [Шаг 0: Overall Score] ──┤ (параллельно)
                                                           ↓
                                  [Шаг 1: Подбор ролей]
                                           ↓
                                  [Юзер выбирает роль]
                                           ↓
                                  [Шаг 2: Переупаковка под роль]
                                           ↓
                                  [Шаг 3: Финальная проверка рекрутером]
                                           ↓
                                  [Юзер правит → повторная проверка (цикл)]
```

### Зависимости между шагами

- Шаг 0 (Диагностика) и Шаг 0 (Overall Score) — **параллельно**, независимы
- Шаг 1 (Подбор ролей) — зависит от диагностики
- Шаг 2 (Переупаковка) — зависит от шагов 0 + 1 + выбор юзера
- Шаг 3 (Финальная проверка) — зависит от шага 2
- Повторная проверка — упрощённый вызов с предыдущим контекстом

---

## API Endpoints

```
POST /api/analyze          — загрузка резюме, запуск шагов 0 (диагностика + скоринг)
GET  /api/status/{task_id} — статус задачи
GET  /api/result/{task_id} — результат (диагностика + скоринг)
POST /api/roles/{task_id}  — запуск шага 1 (подбор ролей)
POST /api/rewrite          — запуск шага 2 (переупаковка), body: {task_id, selected_role}
POST /api/verify/{task_id} — запуск шага 3 (финальная проверка)
POST /api/recheck          — повторная проверка после правок юзера, body: {task_id, updated_resume}
POST /api/save/{task_id}   — сохранить финальную версию
```

---

## Конфигурация Claude API

```python
import anthropic

client = anthropic.AsyncAnthropic(api_key=ANTHROPIC_API_KEY)

# Общие параметры для всех вызовов
MODEL = "claude-haiku-4-5-20251001"
MAX_TOKENS = 4096

# Prompt caching: системные промпты кэшируются между запросами
# cache_control: {"type": "ephemeral"} — кэш 5 мин
```

---

## Шаг 0a: Диагностика резюме

### Промпт

```python
DIAGNOSE_SYSTEM_PROMPT = {
    "type": "text",
    "text": """Ты — опытный рекрутер и карьерный консультант.
Проанализируй резюме и сделай две вещи:

1. ОПРЕДЕЛИ ТИП РЕЗЮМЕ:
- "Список обязанностей" — есть опыт, но описан процессами, без результатов
- "Каша из ролей" — опыт разнородный, непонятно кто этот человек
- "Джун после курсов" — нет реального коммерческого опыта
- "Переходящий" — опыт из другой сферы, хочет сменить роль
- "Нормальный" — есть результаты, нужна полировка

2. ПРОВЕДИ ДИАГНОСТИКУ:
Смотри на резюме как человек, который ежедневно отсматривает десятки откликов и за 30 секунд решает — звать или нет.

Для каждого блока опыта:
- Выдели конкретные формулировки, которые звучат слабо или размыто
- Объясни, почему они не работают
- Предложи, как усилить (без переписывания — только направление)
- Укажи severity: critical / major / minor

Также определи:
- Red flags (частая смена работы, даунгрейд, пробелы)
- Главная проблема этого резюме в одном предложении

Отвечай строго в JSON по указанной схеме.""",
    "cache_control": {"type": "ephemeral"}
}
```

### JSON Schema (structured output)

```json
{
  "type": "object",
  "properties": {
    "resume_type": {
      "type": "string",
      "enum": ["Список обязанностей", "Каша из ролей", "Джун после курсов", "Переходящий", "Нормальный"]
    },
    "resume_type_description": {
      "type": "string",
      "description": "Объяснение типа в 1-2 предложения"
    },
    "main_problem": {
      "type": "string",
      "description": "Главная проблема резюме в одном предложении"
    },
    "red_flags": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "flag": { "type": "string", "description": "Название red flag" },
          "detail": { "type": "string", "description": "Пояснение" },
          "severity": { "type": "string", "enum": ["critical", "major", "minor"] }
        },
        "required": ["flag", "detail", "severity"],
        "additionalProperties": false
      }
    },
    "sections": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "section_title": { "type": "string", "description": "Название компании и роли" },
          "period": { "type": "string" },
          "annotations": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "original_text": { "type": "string", "description": "Цитата из резюме, к которой относится замечание" },
                "type": { "type": "string", "enum": ["critical", "major", "minor"] },
                "comment": { "type": "string", "description": "Что не так и почему" },
                "suggestion": { "type": "string", "description": "Направление для усиления" }
              },
              "required": ["original_text", "type", "comment", "suggestion"],
              "additionalProperties": false
            }
          }
        },
        "required": ["section_title", "period", "annotations"],
        "additionalProperties": false
      }
    }
  },
  "required": ["resume_type", "resume_type_description", "main_problem", "red_flags", "sections"],
  "additionalProperties": false
}
```

---

## Шаг 0b: Overall Score (параллельно с диагностикой)

### Промпт

```python
SCORE_SYSTEM_PROMPT = {
    "type": "text",
    "text": """Ты — AI-система оценки резюме.
Оцени резюме по 10 измерениям, каждое от 0 до 10.
Будь строгим, но справедливым. Типичное «нормальное» резюме получает 50-65 баллов, не выше.

Измерения:
1. Метрики и результаты — есть ли конкретные цифры и достижения
2. Релевантность для целевой роли — насколько опыт соответствует желаемой позиции
3. Конкретика опыта — детали vs общие слова
4. Структура и читаемость — легко ли за 30 сек понять кандидата
5. Навыки и инструменты — актуальны ли, достаточно ли
6. Позиционирование — понятно ли кто этот человек и в чём силён
7. ATS-совместимость — пройдёт ли автоматический фильтр
8. Визуальное впечатление — профессиональность оформления
9. Уникальность — чем выделяется среди 100 похожих резюме
10. Готовность к отправке — можно ли отправить рекрутеру прямо сейчас

Также дай общий вердикт в 2-3 предложения.

Отвечай строго в JSON по указанной схеме.""",
    "cache_control": {"type": "ephemeral"}
}
```

### JSON Schema

```json
{
  "type": "object",
  "properties": {
    "total_score": { "type": "integer", "description": "Сумма всех измерений, 0-100" },
    "dimensions": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "name": { "type": "string" },
          "score": { "type": "integer", "description": "0-10" },
          "comment": { "type": "string", "description": "Краткое пояснение оценки" }
        },
        "required": ["name", "score", "comment"],
        "additionalProperties": false
      },
      "minItems": 10,
      "maxItems": 10
    },
    "verdict": { "type": "string", "description": "Общий вердикт 2-3 предложения" },
    "grade": {
      "type": "string",
      "enum": ["Отличное", "Хорошее", "Нужна полировка", "Нужна переработка", "Полная переделка"]
    }
  },
  "required": ["total_score", "dimensions", "verdict", "grade"],
  "additionalProperties": false
}
```

---

## Шаг 1: Подбор ролей

### Промпт

```python
ROLES_SYSTEM_PROMPT = {
    "type": "text",
    "text": """На основе проведённого анализа определи 2-3 роли, на которые этот кандидат может реально претендовать.

Для каждой роли укажи:
- Название роли
- Уровень соответствия: высокое / среднее / с натяжкой
- Что в опыте работает на эту роль (конкретные пункты из резюме)
- Чего не хватает
- Типичные обязанности на этой роли (чтобы кандидат понял, что его ждёт)

В конце дай рекомендацию: какую роль выбрать как основную для позиционирования и почему.

Контекст диагностики будет передан в сообщении пользователя.

Отвечай строго в JSON по указанной схеме.""",
    "cache_control": {"type": "ephemeral"}
}
```

### User message (формируется динамически)

```python
ROLES_USER_TEMPLATE = """Резюме:
{resume_text}

---

Результат диагностики (Шаг 0):
Тип резюме: {resume_type}
Главная проблема: {main_problem}
Red flags: {red_flags_summary}
"""
```

### JSON Schema

```json
{
  "type": "object",
  "properties": {
    "roles": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "role": { "type": "string" },
          "match_level": { "type": "string", "enum": ["высокое", "среднее", "с натяжкой"] },
          "strengths": {
            "type": "array",
            "items": { "type": "string" },
            "description": "Что в опыте работает на эту роль"
          },
          "gaps": {
            "type": "array",
            "items": { "type": "string" },
            "description": "Чего не хватает"
          },
          "typical_duties": {
            "type": "array",
            "items": { "type": "string" },
            "description": "Типичные обязанности на этой роли"
          }
        },
        "required": ["role", "match_level", "strengths", "gaps", "typical_duties"],
        "additionalProperties": false
      },
      "minItems": 2,
      "maxItems": 3
    },
    "recommendation": {
      "type": "object",
      "properties": {
        "primary_role": { "type": "string" },
        "reasoning": { "type": "string" }
      },
      "required": ["primary_role", "reasoning"],
      "additionalProperties": false
    }
  },
  "required": ["roles", "recommendation"],
  "additionalProperties": false
}
```

---

## Шаг 2: Переупаковка под роль

### Промпт

```python
REWRITE_SYSTEM_PROMPT = {
    "type": "text",
    "text": """Кандидат выбрал целевую роль. Перепиши резюме под эту роль.

Правила:
- Фокус на результатах, а не процессах
- Конкретика вместо общих слов
- Каждый пункт отвечает на вопрос: какую пользу я приношу
- Добавь ключевые слова, которые ищут рекрутеры для этой роли
- Убери или ослабь то, что не работает на выбранную роль
- Ничего не выдумывай — меняй только формулировки и акценты
- Где в оригинале нет цифр — предложи, какие метрики кандидат мог бы уточнить (пометь как [уточнить: ...])
- Для каждого пункта опыта выдели конкретные места, которые нужно дополнить или улучшить (highlights)

Формат:
- Для каждого блока опыта: оригинальный текст + переписанный вариант + точечные highlights с подсказками

Также сгенерируй:
- САММАРИ (2-3 предложения, кто это и в чём силён)
- Блок НАВЫКИ (ключевые + инструменты)
- Блок РЕКОМЕНДАЦИИ (что ещё стоит добавить или уточнить)

Отвечай строго в JSON по указанной схеме.""",
    "cache_control": {"type": "ephemeral"}
}
```

### User message (формируется динамически)

```python
REWRITE_USER_TEMPLATE = """Целевая роль: {selected_role}

Резюме:
{resume_text}

---

Диагностика:
{diagnosis_json}

Подбор ролей:
{roles_json}
"""
```

### JSON Schema

```json
{
  "type": "object",
  "properties": {
    "summary": {
      "type": "string",
      "description": "САММАРИ: 2-3 предложения, кто это и в чём силён"
    },
    "experiences": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "company": { "type": "string" },
          "role": { "type": "string" },
          "period": { "type": "string" },
          "original_bullets": {
            "type": "array",
            "items": { "type": "string" },
            "description": "Оригинальные пункты опыта"
          },
          "rewritten_bullets": {
            "type": "array",
            "items": { "type": "string" },
            "description": "Переписанные пункты опыта"
          },
          "highlights": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "text": { "type": "string", "description": "Фрагмент, на который обратить внимание" },
                "action": { "type": "string", "enum": ["add_metrics", "rephrase", "remove", "clarify", "keep"] },
                "comment": { "type": "string", "description": "Подсказка юзеру, что именно сделать" }
              },
              "required": ["text", "action", "comment"],
              "additionalProperties": false
            }
          },
          "technologies": {
            "type": "array",
            "items": { "type": "string" }
          }
        },
        "required": ["company", "role", "period", "original_bullets", "rewritten_bullets", "highlights"],
        "additionalProperties": false
      }
    },
    "skills": {
      "type": "object",
      "properties": {
        "key_competencies": { "type": "array", "items": { "type": "string" } },
        "tools": { "type": "array", "items": { "type": "string" } },
        "ats_keywords": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Ключевые слова для ATS-фильтров"
        }
      },
      "required": ["key_competencies", "tools", "ats_keywords"],
      "additionalProperties": false
    },
    "recommendations": {
      "type": "array",
      "items": { "type": "string" },
      "description": "Что ещё стоит добавить или уточнить"
    }
  },
  "required": ["summary", "experiences", "skills", "recommendations"],
  "additionalProperties": false
}
```

---

## Шаг 3: Финальная проверка рекрутером

### Промпт

```python
VERIFY_SYSTEM_PROMPT = {
    "type": "text",
    "text": """Прочитай переупакованное резюме как рекрутер, который закрывает вакансию на указанную роль.

Ответь:
- Какие 3 сильные стороны кандидата сразу видны
- Вызывает ли резюме желание позвать на интервью (да / нет / с оговорками)
- Если нет или с оговорками — что конкретно мешает
- Чем это резюме лучше исходного (главное улучшение)
- Оставшиеся риски, которые нужно закрыть на интервью

Отвечай строго в JSON по указанной схеме.""",
    "cache_control": {"type": "ephemeral"}
}
```

### User message

```python
VERIFY_USER_TEMPLATE = """Целевая роль: {selected_role}

Переупакованное резюме:
{rewritten_resume_json}

Оригинальное резюме (для сравнения):
{original_resume_text}
"""
```

### JSON Schema

```json
{
  "type": "object",
  "properties": {
    "top_strengths": {
      "type": "array",
      "items": { "type": "string" },
      "minItems": 3,
      "maxItems": 3,
      "description": "3 сильные стороны, видные сразу"
    },
    "invite_to_interview": {
      "type": "string",
      "enum": ["да", "нет", "с оговорками"]
    },
    "blockers": {
      "type": "array",
      "items": { "type": "string" },
      "description": "Что мешает (если invite != да)"
    },
    "main_improvement": {
      "type": "string",
      "description": "Чем резюме стало лучше (главное изменение)"
    },
    "remaining_risks": {
      "type": "array",
      "items": { "type": "string" },
      "description": "Что нужно закрыть на интервью"
    }
  },
  "required": ["top_strengths", "invite_to_interview", "blockers", "main_improvement", "remaining_risks"],
  "additionalProperties": false
}
```

---

## Повторная проверка (цикл юзера)

### Промпт

```python
RECHECK_SYSTEM_PROMPT = {
    "type": "text",
    "text": """Пользователь внёс правки в резюме после твоих рекомендаций.
Сравни обновлённую версию с предыдущей критикой.

Для каждого предыдущего замечания определи:
- Исправлено ли оно
- Если да — насколько хорошо (отлично / частично / формально)
- Если нет — напомни

Также:
- Пересчитай overall score
- Укажи новые проблемы, если появились
- Дай обновлённый вердикт

Отвечай строго в JSON по указанной схеме.""",
    "cache_control": {"type": "ephemeral"}
}
```

### JSON Schema

```json
{
  "type": "object",
  "properties": {
    "previous_issues_status": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "original_comment": { "type": "string" },
          "status": { "type": "string", "enum": ["исправлено", "частично", "не исправлено"] },
          "quality": { "type": "string", "enum": ["отлично", "хорошо", "формально", "не применимо"] },
          "note": { "type": "string" }
        },
        "required": ["original_comment", "status", "quality", "note"],
        "additionalProperties": false
      }
    },
    "new_issues": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "text": { "type": "string" },
          "type": { "type": "string", "enum": ["critical", "major", "minor"] },
          "comment": { "type": "string" }
        },
        "required": ["text", "type", "comment"],
        "additionalProperties": false
      }
    },
    "updated_score": { "type": "integer" },
    "score_delta": { "type": "integer", "description": "Изменение относительно прошлого скора" },
    "verdict": { "type": "string" }
  },
  "required": ["previous_issues_status", "new_issues", "updated_score", "score_delta", "verdict"],
  "additionalProperties": false
}
```

---

## Парсинг входных файлов

```python
# PDF → текст
# Библиотека: pdfplumber (pip install pdfplumber)
import pdfplumber

def parse_pdf(file_path: str) -> str:
    with pdfplumber.open(file_path) as pdf:
        return "\n".join(page.extract_text() or "" for page in pdf.pages)

# DOCX → текст
# Библиотека: python-docx (pip install python-docx)
from docx import Document

def parse_docx(file_path: str) -> str:
    doc = Document(file_path)
    return "\n".join(p.text for p in doc.paragraphs if p.text.strip())
```

---

## Rate Limiting

```python
import asyncio
import time

class TokenBucket:
    """Зеркалит rate limiter Anthropic на клиенте."""
    def __init__(self, rate_per_minute: int):
        self.rate = rate_per_minute
        self.tokens = float(rate_per_minute)
        self.last_refill = time.monotonic()

    async def acquire(self, cost: int = 1):
        while True:
            now = time.monotonic()
            elapsed = now - self.last_refill
            self.tokens = min(self.rate, self.tokens + elapsed * (self.rate / 60))
            self.last_refill = now
            if self.tokens >= cost:
                self.tokens -= cost
                return
            wait = (cost - self.tokens) / (self.rate / 60)
            await asyncio.sleep(wait)

# Один глобальный инстанс на весь сервис
rpm_limiter = TokenBucket(rate_per_minute=50)  # Tier 1
```

---

## Вызов API — единый клиент

```python
import anthropic
import json

client = anthropic.AsyncAnthropic()

async def call_claude(
    system_prompt: dict,
    user_message: str,
    output_schema: dict,
    max_tokens: int = 4096,
) -> dict:
    """Единая точка вызова Claude API с rate limiting, structured output и retry."""
    await rpm_limiter.acquire(1)

    response = await client.messages.create(
        model="claude-haiku-4-5-20251001",
        max_tokens=max_tokens,
        system=[system_prompt],
        messages=[{"role": "user", "content": user_message}],
        output_config={
            "format": {
                "type": "json_schema",
                "schema": output_schema
            }
        }
    )

    return json.loads(response.content[0].text)
```

---

## Оркестрация пайплайна

```python
async def run_pipeline(resume_text: str) -> dict:
    """Полный пайплайн: диагностика + скоринг (параллельно) → роли."""

    # Шаг 0: параллельно
    diagnose_task = asyncio.create_task(
        call_claude(DIAGNOSE_SYSTEM_PROMPT, resume_text, DIAGNOSE_SCHEMA)
    )
    score_task = asyncio.create_task(
        call_claude(SCORE_SYSTEM_PROMPT, resume_text, SCORE_SCHEMA)
    )
    diagnosis, scores = await asyncio.gather(diagnose_task, score_task)

    # Шаг 1: подбор ролей
    roles_message = ROLES_USER_TEMPLATE.format(
        resume_text=resume_text,
        resume_type=diagnosis["resume_type"],
        main_problem=diagnosis["main_problem"],
        red_flags_summary=json.dumps(diagnosis["red_flags"], ensure_ascii=False),
    )
    roles = await call_claude(ROLES_SYSTEM_PROMPT, roles_message, ROLES_SCHEMA)

    return {
        "diagnosis": diagnosis,
        "scores": scores,
        "roles": roles,
        "status": "awaiting_role_selection"
    }


async def run_rewrite(task_data: dict, selected_role: str) -> dict:
    """Шаг 2: переупаковка после выбора роли юзером."""
    rewrite_message = REWRITE_USER_TEMPLATE.format(
        selected_role=selected_role,
        resume_text=task_data["original_resume"],
        diagnosis_json=json.dumps(task_data["diagnosis"], ensure_ascii=False),
        roles_json=json.dumps(task_data["roles"], ensure_ascii=False),
    )
    rewrite = await call_claude(REWRITE_SYSTEM_PROMPT, rewrite_message, REWRITE_SCHEMA)
    return rewrite


async def run_verify(task_data: dict) -> dict:
    """Шаг 3: финальная проверка рекрутером."""
    verify_message = VERIFY_USER_TEMPLATE.format(
        selected_role=task_data["selected_role"],
        rewritten_resume_json=json.dumps(task_data["rewrite"], ensure_ascii=False),
        original_resume_text=task_data["original_resume"],
    )
    verify = await call_claude(VERIFY_SYSTEM_PROMPT, verify_message, VERIFY_SCHEMA)
    return verify
```

---

## Модель данных (PostgreSQL)

```sql
CREATE TABLE resume_tasks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),

    -- Input
    original_text TEXT NOT NULL,
    file_name TEXT,
    file_type TEXT,  -- 'pdf', 'docx', 'text'

    -- Pipeline state
    status TEXT NOT NULL DEFAULT 'pending',
        -- pending → diagnosing → roles_ready → awaiting_role
        -- → rewriting → verifying → done
    selected_role TEXT,

    -- Results (JSONB)
    diagnosis JSONB,
    scores JSONB,
    roles JSONB,
    rewrite JSONB,
    verification JSONB,

    -- Iteration history
    iterations JSONB DEFAULT '[]'::jsonb,
        -- [{version: 1, text: "...", scores: {...}, recheck: {...}}]

    -- Meta
    total_llm_calls INTEGER DEFAULT 0,
    total_input_tokens INTEGER DEFAULT 0,
    total_output_tokens INTEGER DEFAULT 0,
    total_cost_usd NUMERIC(10, 6) DEFAULT 0
);

CREATE INDEX idx_resume_tasks_status ON resume_tasks(status);
CREATE INDEX idx_resume_tasks_created ON resume_tasks(created_at DESC);
```

---

## Генерация scorecard-картинки

```python
# Библиотека: Pillow (pip install Pillow)
# Генерируем PNG из scores для шаринга в соцсетях

from PIL import Image, ImageDraw, ImageFont

def generate_scorecard(scores: dict, candidate_name: str) -> bytes:
    """
    Генерирует картинку 1200x630 (OG-формат) со скорами.
    Используется для шаринга результатов.
    """
    # TODO: реализовать отрисовку
    # - Радиальный индикатор total_score
    # - 10 горизонтальных баров по dimensions
    # - Цветовое кодирование по severity
    # - Брендинг @analyst_exe
    pass
```

---

## Переменные окружения

```bash
ANTHROPIC_API_KEY=sk-ant-...
DATABASE_URL=postgresql://user:pass@localhost:5432/screener
REDIS_URL=redis://localhost:6379
PORT=8000
TIER_RPM=50              # Текущий тир rate limit
TIER_ITPM=50000
TIER_OTPM=10000
```

---

## Зависимости

```
# requirements.txt
fastapi>=0.104
uvicorn>=0.24
anthropic>=0.40
pdfplumber>=0.10
python-docx>=1.1
pillow>=10.0
asyncpg>=0.29
redis>=5.0
python-multipart>=0.0.6
```

---

## Порядок реализации

1. **Парсинг файлов** — PDF/DOCX → текст
2. **Шаг 0a + 0b** — диагностика + скоринг (параллельно), проверить structured output
3. **Шаг 1** — подбор ролей, передача контекста из шага 0
4. **API endpoints** — FastAPI с очередью задач
5. **Шаг 2** — переупаковка, формирование before/after
6. **Шаг 3** — финальная проверка
7. **Recheck** — повторная проверка после правок
8. **Scorecard** — генерация картинки
9. **Фронтенд** — React UI (прототип уже есть)
10. **Rate limiting + retry** — production-ready обвязка
